This directory contains unit tests for the MIR-based dataflow
analysis.

These unit tests check the dataflow analysis by forcing the compiler
to emit error messasges that describe the dataflow results. The
dataflow results tend to take the form of a mapping from each basic
block to the set of L-values that might satisfy a predicate (namely,
"maybe initialized?" or "maybe uninitialized?") on *exit* from that
basic block.

 * The `#[rustc_mir(dataflow_info_maybe_init)]` attribute prints the
   dataflow results for the "maybe initialized?" predicate.

 * The `#[rustc_mir(dataflow_info_maybe_uninit)]` attribute prints the
   dataflow results for the "maybe initialized?" predicate.

To print such dataflow results in error message form, we print the
list of L-values, attaching the error message to the span of the first
statement in the block. (If the block has no statements, then we
attach it to the span of the block's terminator.)

An example printout of L-values: `[var0=test|var3=ret|arg0=test|tmp5]`
When possible, it includes the source-code name associated with any
var or arg L-value. (It does not include any source information for
temp L-values (e.g. `tmp5` above), because it is not currently easy to
map from a MIR temp to the expression that generated that
temp. Hopefully this will change in the future.)

If you are trying to make sense of the results printed here, you will
want to look at the MIR generated by the compiler (e.g. use the
`--unpretty mir` option).

You might also want to see the graphviz rendering of the MIR with
dataflow annotations. To get the latter, add the attribute
`#[rustc_mir(borrowck_graphviz_postflow="/path/to/suffix.dot")]` to
the function in question. (You can change the content of
`"suffix.dot"` to control the filenames used for the output). This
will generate a separate file for each dataflow analysis, adding a
prefix (corresponding to the name of the analysis) to the filename in
each generated output path.

 * For example, the above attribute will currently cause two files to
   be generated: `/path/to/maybe_init_suffix.dot` and
   `/path/to/maybe_uninit_suffix.dot`.

 * The generated `.dot` file shows both the computed dataflow results
   on *entry* to each block, as well as the gen- and kill-sets that
   were so-called "transfer functions" summarizing the effect of each
   basic block.

 * (In addition to the `borrowck_graphviz_postflow` attribute-key
   noted above, there is also `borrowck_graphviz_preflow`; it has the
   same interface and generates the same set of files, but it renders
   the dataflow state after building the gen- and kill-sets but
   *before* running the dataflow analysis itself, so each entry-set is
   just the initial default state for that dataflow analysis. This is
   less useful for understanding the error message output in these
   tests.)

The `inits-1.rs` test attempts to spell out (in comments) how the
source code ends up mapping to underlying MIR in order to clarify the
origin of seemingly extraneous parts of the analysis (such as
intermediate temps for the expressions).
